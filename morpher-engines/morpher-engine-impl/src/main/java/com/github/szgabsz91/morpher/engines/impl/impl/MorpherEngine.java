/*
 *                    GNU LESSER GENERAL PUBLIC LICENSE
 *                        Version 3, 29 June 2007
 *
 *  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *
 *   This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 *
 *   0. Additional Definitions.
 *
 *   As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 *
 *   "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 *
 *   An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 *
 *   A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 *
 *   The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 *
 *   The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 *
 *   1. Exception to Section 3 of the GNU GPL.
 *
 *   You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 *
 *   2. Conveying Modified Versions.
 *
 *   If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 *
 *    a) under this License, provided that you make a good faith effort to
 *    ensure that, in the event an Application does not supply the
 *    function or data, the facility still operates, and performs
 *    whatever part of its purpose remains meaningful, or
 *
 *    b) under the GNU GPL, with none of the additional permissions of
 *    this License applicable to that copy.
 *
 *   3. Object Code Incorporating Material from Library Header Files.
 *
 *   The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 *
 *    a) Give prominent notice with each copy of the object code that the
 *    Library is used in it and that the Library and its use are
 *    covered by this License.
 *
 *    b) Accompany the object code with a copy of the GNU GPL and this license
 *    document.
 *
 *   4. Combined Works.
 *
 *   You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 *
 *    a) Give prominent notice with each copy of the Combined Work that
 *    the Library is used in it and that the Library and its use are
 *    covered by this License.
 *
 *    b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *    document.
 *
 *    c) For a Combined Work that displays copyright notices during
 *    execution, include the copyright notice for the Library among
 *    these notices, as well as a reference directing the user to the
 *    copies of the GNU GPL and this license document.
 *
 *    d) Do one of the following:
 *
 *        0) Convey the Minimal Corresponding Source under the terms of this
 *        License, and the Corresponding Application Code in a form
 *        suitable for, and under terms that permit, the user to
 *        recombine or relink the Application with a modified version of
 *        the Linked Version to produce a modified Combined Work, in the
 *        manner specified by section 6 of the GNU GPL for conveying
 *        Corresponding Source.
 *
 *        1) Use a suitable shared library mechanism for linking with the
 *        Library.  A suitable mechanism is one that (a) uses at run time
 *        a copy of the Library already present on the user's computer
 *        system, and (b) will operate properly with a modified version
 *        of the Library that is interface-compatible with the Linked
 *        Version.
 *
 *    e) Provide Installation Information, but only if you would otherwise
 *    be required to provide such information under section 6 of the
 *    GNU GPL, and only to the extent that such information is
 *    necessary to install and execute a modified version of the
 *    Combined Work produced by recombining or relinking the
 *    Application with a modified version of the Linked Version. (If
 *    you use option 4d0, the Installation Information must accompany
 *    the Minimal Corresponding Source and Corresponding Application
 *    Code. If you use option 4d1, you must provide the Installation
 *    Information in the manner specified by section 6 of the GNU GPL
 *    for conveying Corresponding Source.)
 *
 *   5. Combined Libraries.
 *
 *   You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 *
 *    a) Accompany the combined library with a copy of the same work based
 *    on the Library, uncombined with any other library facilities,
 *    conveyed under the terms of this License.
 *
 *    b) Give prominent notice with the combined library that part of it
 *    is a work based on the Library, and explaining where to find the
 *    accompanying uncombined form of the same work.
 *
 *   6. Revised Versions of the GNU Lesser General Public License.
 *
 *   The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.
 *
 *   Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 *
 *   If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */
package com.github.szgabsz91.morpher.engines.impl.impl;

import com.github.szgabsz91.morpher.analyzeragents.api.IAnalyzerAgent;
import com.github.szgabsz91.morpher.analyzeragents.api.model.AnalyzerAgentResponse;
import com.github.szgabsz91.morpher.analyzeragents.api.model.AnnotationTokenizerResult;
import com.github.szgabsz91.morpher.analyzeragents.api.model.LemmaMap;
import com.github.szgabsz91.morpher.analyzeragents.api.model.MarkovRoute;
import com.github.szgabsz91.morpher.analyzeragents.api.model.ProbabilisticAffixType;
import com.github.szgabsz91.morpher.core.io.ICustomDeserializer;
import com.github.szgabsz91.morpher.core.io.ICustomSerializer;
import com.github.szgabsz91.morpher.core.io.Serializer;
import com.github.szgabsz91.morpher.core.model.AffixType;
import com.github.szgabsz91.morpher.core.model.Corpus;
import com.github.szgabsz91.morpher.core.model.FrequencyAwareWordPair;
import com.github.szgabsz91.morpher.core.model.Word;
import com.github.szgabsz91.morpher.core.services.ServiceProvider;
import com.github.szgabsz91.morpher.engines.api.IMorpherEngine;
import com.github.szgabsz91.morpher.engines.api.model.InflectionInput;
import com.github.szgabsz91.morpher.engines.api.model.InflectionOrderedInput;
import com.github.szgabsz91.morpher.engines.api.model.LemmatizationInput;
import com.github.szgabsz91.morpher.engines.api.model.LemmatizationInputWithAffixTypes;
import com.github.szgabsz91.morpher.engines.api.model.MorpherEngineResponse;
import com.github.szgabsz91.morpher.engines.api.model.PreanalyzedTrainingItems;
import com.github.szgabsz91.morpher.engines.api.model.ProbabilisticStep;
import com.github.szgabsz91.morpher.engines.api.model.Step;
import com.github.szgabsz91.morpher.engines.impl.converters.MorpherEngineConverter;
import com.github.szgabsz91.morpher.engines.impl.methodholders.IMorpherMethodHolder;
import com.github.szgabsz91.morpher.engines.impl.impl.methodholders.LazyMorpherMethodHolder;
import com.github.szgabsz91.morpher.engines.impl.impl.model.StepCandidate;
import com.github.szgabsz91.morpher.engines.impl.impl.probability.IProbabilityCalculator;
import com.github.szgabsz91.morpher.engines.impl.methodholderfactories.EagerMorpherMethodHolderFactory;
import com.github.szgabsz91.morpher.engines.impl.methodholderfactories.IMorpherMethodHolderFactory;
import com.github.szgabsz91.morpher.engines.impl.methodholderfactories.LazyMorpherMethodHolderFactory;
import com.github.szgabsz91.morpher.engines.impl.protocolbuffers.MorpherEngineMessage;
import com.github.szgabsz91.morpher.methods.api.IMorpherMethod;
import com.github.szgabsz91.morpher.methods.api.factories.IAbstractMethodFactory;
import com.github.szgabsz91.morpher.methods.api.model.MethodResponse;
import com.github.szgabsz91.morpher.methods.api.model.ProbabilisticWord;
import com.github.szgabsz91.morpher.methods.api.model.TrainingSet;
import com.google.protobuf.Any;
import com.google.protobuf.InvalidProtocolBufferException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.zip.GZIPOutputStream;

import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.mapping;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import static java.util.stream.Collectors.toSet;

/**
 * Default implementation of the {@link IMorpherEngine} interface.
 *
 * @author szgabsz91
 */
public class MorpherEngine implements IMorpherEngine<MorpherEngineMessage>, ICustomSerializer, ICustomDeserializer {

    private static final Logger LOGGER = LoggerFactory.getLogger(MorpherEngine.class);

    private final ServiceProvider serviceProvider;
    private Map<AffixType, IMorpherMethodHolder> methodHolderMap;
    private IMorpherMethodHolderFactory methodHolderFactory;
    private IAbstractMethodFactory<?, ?> abstractMethodFactory;
    private IAnalyzerAgent<?> analyzerAgent;
    private IProbabilityCalculator probabilityCalculator;
    private Double minimumAggregatedWeightThreshold;
    private boolean dirty;

    /**
     * Constructor that sets the underlying services.
     * @param serviceProvider the {@link ServiceProvider} instance
     * @param methodHolderMap the map of {@link LazyMorpherMethodHolder} instances that hold {@link IMorpherMethod}s
     * @param methodHolderFactory the {@link IMorpherMethodHolderFactory} instance
     * @param abstractMethodFactory the {@link IAbstractMethodFactory} instance
     * @param analyzerAgent a language dependent {@link IAnalyzerAgent} implementation
     * @param probabilityCalculator the {@link IProbabilityCalculator} implementation
     * @param minimumAggregatedWeightThreshold the minimum threshold of the aggregated weight
     *                                         of the {@link MorpherEngineResponse}s
     */
    public MorpherEngine(
            final ServiceProvider serviceProvider,
            final Map<AffixType, IMorpherMethodHolder> methodHolderMap,
            final IMorpherMethodHolderFactory methodHolderFactory,
            final IAbstractMethodFactory<?, ?> abstractMethodFactory,
            final IAnalyzerAgent<?> analyzerAgent,
            final IProbabilityCalculator probabilityCalculator,
            final Double minimumAggregatedWeightThreshold) {
        this.serviceProvider = serviceProvider;
        this.methodHolderMap = methodHolderMap;
        this.methodHolderFactory = methodHolderFactory;
        this.abstractMethodFactory = abstractMethodFactory;
        this.analyzerAgent = analyzerAgent;
        this.probabilityCalculator = probabilityCalculator;
        this.minimumAggregatedWeightThreshold = minimumAggregatedWeightThreshold;
    }

    /**
     * Constructor that sets the underlying services.
     * @param serviceProvider the {@link ServiceProvider} instance
     * @param methodHolderFactory the {@link IMorpherMethodHolderFactory} instance
     * @param abstractMethodFactory the {@link IAbstractMethodFactory} instance
     * @param analyzerAgent a language dependent {@link IAnalyzerAgent} implementation
     * @param probabilityCalculator the {@link IProbabilityCalculator} implementation
     * @param minimumAggregatedWeightThreshold the minimum threshold of the aggregated weight
     *                                         of the {@link MorpherEngineResponse}s
     */
    public MorpherEngine(
            final ServiceProvider serviceProvider,
            final IMorpherMethodHolderFactory methodHolderFactory,
            final IAbstractMethodFactory<?, ?> abstractMethodFactory,
            final IAnalyzerAgent<?> analyzerAgent,
            final IProbabilityCalculator probabilityCalculator,
            final Double minimumAggregatedWeightThreshold) {
        this(
                serviceProvider,
                new HashMap<>(),
                methodHolderFactory,
                abstractMethodFactory,
                analyzerAgent,
                probabilityCalculator,
                minimumAggregatedWeightThreshold
        );
    }

    /**
     * Closes the underlying autoclosable services.
     */
    @Override
    public void close() {
        this.analyzerAgent.close();
        this.methodHolderMap.values().forEach(IMorpherMethodHolder::close);
    }

    /**
     * Returns the map of {@link IMorpherMethodHolder} instances.
     * @return the map of {@link IMorpherMethodHolder} instances
     */
    public Map<AffixType, IMorpherMethodHolder> getMethodHolderMap() {
        return methodHolderMap;
    }

    /**
     * Returns the {@link IMorpherMethodHolderFactory} instance.
     * @return the {@link IMorpherMethodHolderFactory} instance
     */
    public IMorpherMethodHolderFactory getMethodHolderFactory() {
        return methodHolderFactory;
    }

    /**
     * Returns the {@link IAbstractMethodFactory} instance.
     * @return the {@link IAbstractMethodFactory} instance
     */
    public IAbstractMethodFactory<?, ?> getAbstractMethodFactory() {
        return abstractMethodFactory;
    }

    /**
     * Returns the {@link IAnalyzerAgent} instance.
     * @return the {@link IAnalyzerAgent} instance
     */
    public IAnalyzerAgent<?> getAnalyzerAgent() {
        return analyzerAgent;
    }

    /**
     * Returns the {@link IProbabilityCalculator} instance.
     * @return the {@link IProbabilityCalculator} instance
     */
    public IProbabilityCalculator getProbabilityCalculator() {
        return probabilityCalculator;
    }

    /**
     * Returns the minimum aggregated weight threshold.
     * @return the minimum aggregated weight threshold
     */
    public Double getMinimumAggregatedWeightThreshold() {
        return minimumAggregatedWeightThreshold;
    }

    /**
     * Returns if the engine is eager.
     * @return true if the engine is eager, false if lazy
     */
    @Override
    public boolean isEager() {
        return this.methodHolderFactory instanceof EagerMorpherMethodHolderFactory;
    }

    /**
     * Returns if the engine is lazy.
     * @return true if the engine is lazy, false if eager
     */
    @Override
    public boolean isLazy() {
        return this.methodHolderFactory instanceof LazyMorpherMethodHolderFactory;
    }

    /**
     * Tries to morphologically analyze the words in the given corpus and generate the appropriate word pairs, then has
     * the new word pairs learnt with the method of the appropriate affix types.
     *
     * @param corpus the corpus containing the new words
     */
    @Override
    public void learn(final Corpus corpus) {
        final AnalyzerAgentResponse response = this.analyzerAgent.analyze(corpus.getWords());
        final Map<AffixType, Set<FrequencyAwareWordPair>> wordPairMap = response.getWordPairMap();
        wordPairMap.forEach((affixType, wordPairs) -> {
            final TrainingSet trainingSet = TrainingSet.of(wordPairs);
            final IMorpherMethodHolder methodHolder = this.getMethodHolder(affixType);
            final IMorpherMethod<?> method = methodHolder.get();
            method.learn(trainingSet);
            methodHolder.save(method);
            methodHolder.clear();
        });
        if (!wordPairMap.isEmpty()) {
            this.dirty = true;
        }
    }

    /**
     * Learns the given {@link PreanalyzedTrainingItems} instance.
     * @param preanalyzedTrainingItems the {@link PreanalyzedTrainingItems} instance
     */
    @Override
    public void learn(final PreanalyzedTrainingItems preanalyzedTrainingItems) {
        final Map<String, List<AnnotationTokenizerResult>> annotationTokenizerResults = preanalyzedTrainingItems
                .stream()
                .map(preanalyzedTrainingItem -> {
                    final AnnotationTokenizerResult annotationTokenizerResult =
                            preanalyzedTrainingItem.getAnnotationTokenizerResult();
                    final String lemma = annotationTokenizerResult.getLemma();
                    return Map.entry(lemma, annotationTokenizerResult);
                })
                .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toList())));
        this.analyzerAgent.learnAnnotationTokenizerResults(annotationTokenizerResults);

        final Set<List<AffixType>> affixTypeOrders = preanalyzedTrainingItems
                .stream()
                .map(preanalyzedTrainingItem -> {
                    final AnnotationTokenizerResult annotationTokenizerResult =
                            preanalyzedTrainingItem.getAnnotationTokenizerResult();
                    return annotationTokenizerResult.getAffixTypes();
                })
                .collect(toSet());
        this.analyzerAgent.learnAffixTypeOrders(affixTypeOrders);

        final Map<Word, Set<AffixType>> lemmaMap = preanalyzedTrainingItems
                .stream()
                .map(preanalyzedTrainingItem -> {
                    final AnnotationTokenizerResult annotationTokenizerResult =
                            preanalyzedTrainingItem.getAnnotationTokenizerResult();
                    final Word lemma = Word.of(annotationTokenizerResult.getLemma());
                    final AffixType pos = annotationTokenizerResult.getAffixTypes().get(0);
                    return Map.entry(lemma, pos);
                })
                .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toSet())));
        this.analyzerAgent.learnLemmas(LemmaMap.of(lemmaMap));

        final Map<AffixType, Set<FrequencyAwareWordPair>> wordPairMap = preanalyzedTrainingItems
                .stream()
                .map(preanalyzedTrainingItem -> {
                    final AnnotationTokenizerResult annotationTokenizerResult =
                            preanalyzedTrainingItem.getAnnotationTokenizerResult();
                    final List<AffixType> affixTypes = annotationTokenizerResult.getAffixTypes();
                    final AffixType lastAffixType = affixTypes.get(affixTypes.size() - 1);
                    final FrequencyAwareWordPair wordPair = preanalyzedTrainingItem.getWordPair();
                    return Map.entry(lastAffixType, wordPair);
                })
                .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toSet())));
        wordPairMap.forEach((affixType, wordPairs) -> {
            final TrainingSet trainingSet = TrainingSet.of(wordPairs);
            final IMorpherMethodHolder methodHolder = this.getMethodHolder(affixType);
            final IMorpherMethod<?> method = methodHolder.get();
            method.learn(trainingSet);
            methodHolder.save(method);
            methodHolder.clear();
        });
        if (!wordPairMap.isEmpty()) {
            this.dirty = true;
        }
    }

    /**
     * Adds the words in the given {@link LemmaMap} to the set of known lemmas.
     * @param lemmaMap the {@link LemmaMap} instance
     */
    @Override
    public void learn(final LemmaMap lemmaMap) {
        this.analyzerAgent.learnLemmas(lemmaMap);
    }

    /**
     * Performs inflection using the given {@link InflectionInput} that contains the input word and the unordered set of
     * affix types.
     *
     * @param inflectionInput the inflection input
     * @return the list of responses, ordered by descending probability values
     */
    @Override
    public List<MorpherEngineResponse> inflect(final InflectionInput inflectionInput) {
        final Word input = inflectionInput.getInput();
        final Set<AffixType> affixTypes = inflectionInput.getAffixTypes();

        Stream<MorpherEngineResponse> morpherEngineResponseStream = this.analyzerAgent.sortAffixTypes(input, affixTypes)
                .stream()
                .filter(markovRoute -> this.filterMarkovRoute(markovRoute, input))
                .map(markovRoute -> this.inflect(input, markovRoute))
                .flatMap(Collection::stream)
                .distinct();

        if (this.minimumAggregatedWeightThreshold != null) {
            morpherEngineResponseStream = morpherEngineResponseStream
                    .filter(morpherEngineResponse -> {
                        return morpherEngineResponse.getAggregatedWeight() >= this.minimumAggregatedWeightThreshold;
                    });
        }

        return morpherEngineResponseStream
                .sorted()
                .collect(toList());
    }

    /**
     * Performs inflection using the given {@link InflectionOrderedInput} that contains the input word and the ordered
     * list of affix types.
     *
     * @param inflectionOrderedInput the inflection input
     * @return the response
     */
    @Override
    public List<MorpherEngineResponse> inflect(final InflectionOrderedInput inflectionOrderedInput) {
        final Word input = inflectionOrderedInput.getInput();
        final List<AffixType> affixTypes = inflectionOrderedInput.getAffixTypes();
        final MarkovRoute markovRoute = this.analyzerAgent.calculateProbabilities(affixTypes);

        Stream<MorpherEngineResponse> morpherEngineResponseStream = this.inflect(input, markovRoute)
                .stream()
                .distinct();

        if (this.minimumAggregatedWeightThreshold != null) {
            morpherEngineResponseStream = morpherEngineResponseStream
                    .filter(morpherEngineResponse -> {
                        return morpherEngineResponse.getAggregatedWeight() >= this.minimumAggregatedWeightThreshold;
                    });
        }

        return morpherEngineResponseStream
                .sorted()
                .collect(toList());
    }

    /**
     * Performs lemmatization using the given inflected word form.
     *
     * {@inheritDoc}
     */
    @Override
    public List<MorpherEngineResponse> lemmatize(final LemmatizationInput lemmatizationInput) {
        final Word inflectedForm = lemmatizationInput.getInput();
        final Set<StepCandidate> candidates = new HashSet<>();
        final List<StepCandidate> candidateLeaves = new ArrayList<>();

        final Consumer<StepCandidate> candidateConsumer = stepCandidate -> {
            final ProbabilisticAffixType probabilisticAffixType = stepCandidate.getProbabilisticAffixType();
            final AffixType affixType = probabilisticAffixType.getAffixType();

            if (this.analyzerAgent.isPOS(affixType)) {
                final Word output = stepCandidate.getParent().getOutput().getWord();
                final boolean canStop = this.analyzerAgent.getPOSCandidates(output)
                        .stream()
                        .map(ProbabilisticAffixType::getAffixType)
                        .anyMatch(currentAffixType -> currentAffixType.equals(affixType));

                if (canStop) {
                    final Word word = stepCandidate.getInput();
                    final List<AffixType> affixTypes = createAffixTypes(stepCandidate);
                    final ProbabilisticAffixType endingProbabilisticAffixType =
                            this.analyzerAgent.getEndingLemmatizationCandidate(affixTypes);
                    LOGGER.trace("[LEMMATIZATION] [{}] Found PoS: {}", word, probabilisticAffixType);
                    final StepCandidate endingStepCandidate =
                            new StepCandidate(endingProbabilisticAffixType, word, stepCandidate);
                    candidateLeaves.add(endingStepCandidate);
                }
            }
            else {
                candidates.add(stepCandidate);
            }
        };

        // First candidates
        this.analyzerAgent.getLemmatizationCandidates(Collections.emptyList())
                .stream()
                .map(candidate -> new StepCandidate(candidate, inflectedForm))
                .forEach(candidateConsumer);

        while (!candidates.isEmpty()) {
            final StepCandidate candidate = candidates.iterator().next();
            candidates.remove(candidate);

            if (lemmatizationInput instanceof LemmatizationInputWithAffixTypes) {
                final LemmatizationInputWithAffixTypes lemmatizationInputWithAffixTypes =
                        (LemmatizationInputWithAffixTypes) lemmatizationInput;
                final List<AffixType> affixTypeCandidates = generateAffixTypeCandidates(candidate);
                if (!endsWith(lemmatizationInputWithAffixTypes.getAffixTypes(), affixTypeCandidates)) {
                    continue;
                }
            }

            final Word input = candidate.getInput();
            final ProbabilisticAffixType probabilisticAffixType = candidate.getProbabilisticAffixType();
            final AffixType affixType = probabilisticAffixType.getAffixType();
            final IMorpherMethodHolder methodHolder = this.getMethodHolder(affixType);
            final IMorpherMethod<?> method = methodHolder.get();
            methodHolder.clear();
            final Optional<MethodResponse> response = method.lemmatize(input);
            if (!response.isPresent()) {
                continue;
            }
            final MethodResponse methodResponse = response.get();
            final List<ProbabilisticWord> probabilisticWords = methodResponse.getResults();

            for (final ProbabilisticWord probabilisticWord : probabilisticWords) {
                final Word newWord = probabilisticWord.getWord();
                final StepCandidate newCandidate = new StepCandidate(candidate);
                newCandidate.setOutput(probabilisticWord);

                final List<AffixType> affixTypes = createSteps(newCandidate)
                        .stream()
                        .map(ProbabilisticStep::getAffixType)
                        .collect(toList());
                this.analyzerAgent.getLemmatizationCandidates(affixTypes)
                        .stream()
                        .map(c -> new StepCandidate(c, newWord, newCandidate))
                        .forEach(candidateConsumer);
            }
        }

        final List<MorpherEngineResponse> morpherEngineResponses = candidateLeaves
                .stream()
                .map(this::createLemmatizationResponse)
                .filter(lemmatizationResponse -> {
                    final List<ProbabilisticStep> steps = lemmatizationResponse.getSteps();
                    final List<AffixType> affixTypes = IntStream.range(0, steps.size())
                            .map(i -> steps.size() - i - 1)
                            .mapToObj(steps::get)
                            .map(Step::getAffixType)
                            .collect(toList());
                    affixTypes.add(0, lemmatizationResponse.getPos().getAffixType());
                    final boolean isAffixTypeOrderValid = this.analyzerAgent.isAffixTypeOrderValid(affixTypes);
                    if (!isAffixTypeOrderValid) {
                        LOGGER.trace("[LEMMATIZATION] Dropping affix type chain {} as it is invalid", affixTypes);
                    }
                    return isAffixTypeOrderValid;
                })
                .distinct()
                .collect(toList());

        final double maximumAffixTypeChainProbability = morpherEngineResponses
                .stream()
                .mapToDouble(MorpherEngineResponse::getAffixTypeChainProbability)
                .max()
                .orElse(0.0);

        morpherEngineResponses.forEach(morpherEngineResponse -> {
            final double originalAffixTypeChainProbability = morpherEngineResponse.getAffixTypeChainProbability();
            final double normalizedAffixTypeChainProbability =
                    originalAffixTypeChainProbability / maximumAffixTypeChainProbability;
            morpherEngineResponse.setNormalizedAffixTypeChainProbability(normalizedAffixTypeChainProbability);
            this.probabilityCalculator.setProbability(morpherEngineResponse);
        });

        Stream<MorpherEngineResponse> morpherEngineResponseStream = morpherEngineResponses
                .stream();

        if (this.minimumAggregatedWeightThreshold != null) {
            morpherEngineResponseStream = morpherEngineResponseStream
                    .filter(morpherEngineResponse -> {
                        return morpherEngineResponse.getAggregatedWeight() >= this.minimumAggregatedWeightThreshold;
                    });
        }

        return morpherEngineResponseStream
                .sorted()
                .collect(toList());
    }

    /**
     * Returns the supported affix types.
     *
     * {@inheritDoc}
     */
    @Override
    public Set<AffixType> getSupportedAffixTypes() {
        return this.analyzerAgent.getSupportedAffixTypes();
    }

    /**
     * Returns if this engine is dirty, i.e. it has learnt at least one word since its saving/loading.
     * @return true if this engine is dirty, false otherwise
     */
    @Override
    public boolean isDirty() {
        return dirty;
    }

    /**
     * Cleans the state of the engine so that it is not dirty anymore.
     */
    @Override
    public void clean() {
        this.dirty = false;
    }

    /**
     * Converts the state to a message.
     * @return the message
     */
    @Override
    public MorpherEngineMessage toMessage() {
        final MorpherEngineConverter morpherEngineConverter = new MorpherEngineConverter(this.serviceProvider);
        return morpherEngineConverter.convert(this);
    }

    /**
     * Loads the state from the given message.
     * @param message the message
     */
    @Override
    public void fromMessage(final MorpherEngineMessage message) {
        this.close();
        final MorpherEngineConverter morpherEngineConverter = new MorpherEngineConverter(this.serviceProvider);
        final MorpherEngine morpherEngine = morpherEngineConverter.convertBack(message);
        this.methodHolderMap = morpherEngine.methodHolderMap;
        this.abstractMethodFactory = morpherEngine.abstractMethodFactory;
        this.analyzerAgent = morpherEngine.analyzerAgent;
        this.probabilityCalculator = morpherEngine.probabilityCalculator;
        this.minimumAggregatedWeightThreshold = morpherEngine.getMinimumAggregatedWeightThreshold();
        this.dirty = false;
    }

    /**
     * Loads the state from the given message.
     * @param message the message
     * @throws InvalidProtocolBufferException if the provided message is not an {@link MorpherEngineMessage}
     */
    @Override
    public void fromMessage(final Any message) throws InvalidProtocolBufferException {
        if (!message.is(MorpherEngineMessage.class)) {
            throw new InvalidProtocolBufferException("The provided message is not a MorpherEngineMessage: " + message);
        }

        final MorpherEngineMessage morpherEngineMessage = message.unpack(MorpherEngineMessage.class);
        this.fromMessage(morpherEngineMessage);
    }

    /**
     * Saves the internal state of the engine to the given file.
     * @param file the file to save the state to
     * @throws IOException if the state cannot be saved
     */
    @Override
    public void saveTo(final Path file) throws IOException {
        final MorpherEngineConverter converter = new MorpherEngineConverter(this.serviceProvider);
        final Serializer<MorpherEngine, MorpherEngineMessage> serializer = new Serializer<>(converter, this);
        serializer.serialize(this, file);

        this.dirty = false;
    }

    /**
     * Loads the internal state of the engine from the given file.
     * @param file the file to load the state from
     * @throws IOException if the state cannot be loaded
     */
    @Override
    public void loadFrom(final Path file) throws IOException {
        this.close();

        final MorpherEngineConverter converter = new MorpherEngineConverter(this.serviceProvider);
        final Serializer<MorpherEngine, MorpherEngineMessage> serializer = new Serializer<>(converter, this);
        final MorpherEngine engine = serializer.deserialize(file);

        this.methodHolderMap = engine.methodHolderMap;
        this.abstractMethodFactory = engine.abstractMethodFactory;
        this.analyzerAgent = engine.analyzerAgent;
        this.probabilityCalculator = engine.probabilityCalculator;
        this.dirty = false;
    }

    /**
     * Serializes the state of this {@link MorpherEngine} to the given file.
     *
     * <p>If the method returns false, {@link Serializer} will try to serialize the object with its own logic.</p>
     *
     * {@inheritDoc}
     */
    @Override
    public boolean serialize(final Path file) {
        if (!(this.methodHolderFactory instanceof LazyMorpherMethodHolderFactory)) {
            return false;
        }

        Path tempFolder = null;

        try {
            tempFolder = Files.createTempDirectory("morpher-engine");
            final String absoluteTempFolderPath = tempFolder.toAbsolutePath().toString();

            // Serialize engine
            final Path engineFile = Paths.get(absoluteTempFolderPath, "engine.pb");
            final MorpherEngineConverter morpherEngineConverter =
                    new MorpherEngineConverter(this.serviceProvider, true);
            final MorpherEngineMessage morpherEngineMessage = morpherEngineConverter.convert(this);
            try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(engineFile))) {
                morpherEngineMessage.writeTo(gzipOutputStream);
            }

            // Serialize methods
            for (final Map.Entry<AffixType, IMorpherMethodHolder> entry : this.methodHolderMap.entrySet()) {
                final AffixType affixType = entry.getKey();
                final String methodFilename = affixType.toString()
                        .replace('<', '(')
                        .replace('>', ')') +
                        ".pb";
                final Path methodFile = Paths.get(absoluteTempFolderPath, methodFilename);
                final IMorpherMethodHolder morpherMethodHolder = entry.getValue();
                final IMorpherMethod<?> morpherMethod = morpherMethodHolder.get();
                morpherMethodHolder.clear();
                morpherMethod.saveTo(methodFile);
            }

            Serializer.zipFolder(tempFolder, file);
            return true;
        }
        catch (final IOException e) {
            throw new IllegalStateException("Cannot serialize Morpher Engine", e);
        }
        finally {
            if (tempFolder != null) {
                Serializer.deleteFolder(tempFolder);
            }
        }
    }

    /**
     * Deserializes the state of this {@link MorpherEngine} from the given file.
     *
     * <p>If the method returns false, {@link Serializer} will try to serialize the object with its own logic.</p>
     *
     * {@inheritDoc}
     */
    @Override
    public boolean deserialize(final Path file) {
        if (!(this.methodHolderFactory instanceof LazyMorpherMethodHolderFactory)) {
            return false;
        }

        Path tempFolder = null;

        try {
            tempFolder = Files.createTempDirectory("morpher-engine");
            Serializer.unzipFolder(file, tempFolder);
            final String absoluteTempFolderPath = tempFolder.toAbsolutePath().toString();

            // Deserialize engine
            final Path engineFile = Paths.get(absoluteTempFolderPath, "engine.pb");
            final MorpherEngineConverter morpherEngineConverter =
                    new MorpherEngineConverter(this.serviceProvider, true);
            final MorpherEngineMessage morpherEngineMessage = morpherEngineConverter.parse(engineFile);
            final MorpherEngine engine = morpherEngineConverter.convertBack(morpherEngineMessage);
            this.methodHolderMap = engine.methodHolderMap;
            this.abstractMethodFactory = engine.abstractMethodFactory;
            this.analyzerAgent = engine.analyzerAgent;
            this.probabilityCalculator = engine.probabilityCalculator;
            this.dirty = false;

            // Deserialize methods
            this.methodHolderMap = Files.list(tempFolder)
                    .filter(Files::isRegularFile)
                    .filter(methodFile -> !methodFile.getFileName().toString().equals("engine.pb"))
                    .map(methodFile -> {
                        final String filename = methodFile.getFileName().toString();
                        final String affixTypeString = filename
                                .replace('(', '<')
                                .replace(')', '>')
                                .substring(0, filename.length() - 3);
                        final AffixType affixType = AffixType.of(affixTypeString);
                        final Supplier<IMorpherMethod<?>> bidirectionalFactory =
                                this.abstractMethodFactory.getBidirectionalFactory(affixType);
                        final IMorpherMethod<?> morpherMethod = bidirectionalFactory.get();
                        try {
                            morpherMethod.loadFrom(methodFile);
                        }
                        catch (final IOException e) {
                            throw new IllegalStateException(
                                    "Cannot load Morpher Method state from file " + methodFile,
                                    e
                            );
                        }
                        final IMorpherMethodHolder methodHolder =
                                this.methodHolderFactory.create(affixType, this.abstractMethodFactory, morpherMethod);
                        methodHolder.save(morpherMethod);
                        methodHolder.clear();
                        return Map.entry(affixType, methodHolder);
                    })
                    .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));

            return true;
        }
        catch (final IOException e) {
            throw new IllegalStateException("Cannot deserialize Morpher Engine", e);
        }
        finally {
            if (tempFolder != null) {
                Serializer.deleteFolder(tempFolder);
            }
        }
    }

    private IMorpherMethodHolder getMethodHolder(final AffixType affixType) {
        if (this.methodHolderMap.containsKey(affixType)) {
            return this.methodHolderMap.get(affixType);
        }

        final IMorpherMethodHolder methodHolder = this.methodHolderFactory.create(
                affixType,
                this.abstractMethodFactory,
                this.abstractMethodFactory.getBidirectionalFactory(affixType).get()
        );
        this.methodHolderMap.put(affixType, methodHolder);
        return methodHolder;
    }

    private MorpherEngineResponse createLemmatizationResponse(final StepCandidate candidateLeaf) {
        final double endingProbability = candidateLeaf.getProbability();
        final StepCandidate posCandidate = candidateLeaf.getParent();
        final ProbabilisticAffixType pos = posCandidate.getProbabilisticAffixType();
        final double posProbability = pos.getProbability();
        final StepCandidate stepCandidate = posCandidate.getParent();
        final List<ProbabilisticStep> steps = createSteps(stepCandidate);
        final double aggregatedStepProbability = steps
                .stream()
                .mapToDouble(ProbabilisticStep::getAggregatedProbability)
                .reduce(1.0, (x, y) -> x * y);
        final double probability = endingProbability * posProbability * aggregatedStepProbability;

        return MorpherEngineResponse.lemmatizationResponse(
                steps.get(0).getInput(),
                stepCandidate.getOutput().getWord(),
                pos,
                probability,
                steps
        );
    }

    private static List<ProbabilisticStep> createSteps(final StepCandidate candidateLeaf) {
        StepCandidate currentCandidate = candidateLeaf;
        final List<ProbabilisticStep> steps = new LinkedList<>();

        do {
            final Word input = currentCandidate.getInput();
            final ProbabilisticWord probabilisticOutput = currentCandidate.getOutput();
            final Word output = probabilisticOutput.getWord();
            final ProbabilisticAffixType probabilisticAffixType = currentCandidate.getProbabilisticAffixType();
            final AffixType affixType = probabilisticAffixType.getAffixType();
            final double affixTypeProbability = probabilisticAffixType.getProbability();
            final double outputWordProbability = probabilisticOutput.getProbability();
            final double aggregatedProbability = affixTypeProbability * outputWordProbability;
            final ProbabilisticStep step = new ProbabilisticStep(
                    input,
                    output,
                    affixType,
                    affixTypeProbability,
                    outputWordProbability,
                    aggregatedProbability
            );
            steps.add(0, step);
            currentCandidate = currentCandidate.getParent();
        }
        while (currentCandidate != null);

        return steps;
    }

    private static List<AffixType> createAffixTypes(final StepCandidate candidateLeaf) {
        final List<AffixType> affixTypes = new LinkedList<>();
        StepCandidate currentCandidate = candidateLeaf;

        do {
            final AffixType affixType = currentCandidate.getAffixType();
            affixTypes.add(0, affixType);
            currentCandidate = currentCandidate.getParent();
        }
        while (currentCandidate != null);

        return affixTypes;
    }

    private boolean filterMarkovRoute(final MarkovRoute markovRoute, final Word input) {
        return this.analyzerAgent.getPOSCandidates(input)
                .stream()
                .map(ProbabilisticAffixType::getAffixType)
                .anyMatch(pos -> markovRoute.getAffixTypes().get(0).getAffixType().equals(pos));
    }

    private List<MorpherEngineResponse> inflect(
            final Word input,
            final MarkovRoute markovRoute) {
        LOGGER.trace("[INFLECTION] Processing Markov route: {}", markovRoute);
        final List<ProbabilisticAffixType> probabilisticAffixTypes = markovRoute.getAffixTypes();
        final ProbabilisticAffixType pos = probabilisticAffixTypes.remove(0);
        Set<StepCandidate> stepCandidates = new HashSet<>();
        stepCandidates.add(new StepCandidate(pos, input, null, ProbabilisticWord.of(input, 1.0)));

        for (final ProbabilisticAffixType probabilisticAffixType : probabilisticAffixTypes) {
            final AffixType affixType = probabilisticAffixType.getAffixType();
            final IMorpherMethodHolder methodHolder = this.getMethodHolder(affixType);
            final IMorpherMethod<?> method = methodHolder.get();
            methodHolder.clear();
            final Set<StepCandidate> newCandidates = new HashSet<>();

            for (final StepCandidate stepCandidate : stepCandidates) {
                final ProbabilisticWord currentProbabilisticWord = stepCandidate.getOutput();
                final Word currentWord = currentProbabilisticWord.getWord();
                final Optional<MethodResponse> response = method.inflect(currentWord);
                if (!response.isPresent()) {
                    LOGGER.trace("[INFLECTION] Empty response received");
                    continue;
                }
                final List<ProbabilisticWord> newProbabilisticWords = response.get().getResults();

                for (final ProbabilisticWord newProbabilisticWord : newProbabilisticWords) {
                    final StepCandidate newStepCandidate = new StepCandidate(
                            probabilisticAffixType,
                            currentWord,
                            stepCandidate,
                            newProbabilisticWord
                    );
                    newCandidates.add(newStepCandidate);
                }
            }

            stepCandidates = newCandidates;
        }

        final List<MorpherEngineResponse> morpherEngineResponses = stepCandidates
                .stream()
                .map(stepCandidate -> {
                    final Word output = stepCandidate.getOutput().getWord();
                    final List<ProbabilisticStep> steps = new LinkedList<>();
                    StepCandidate currentStepCandidate = stepCandidate;
                    while (currentStepCandidate.getParent() != null) {
                        final Word previousWord = currentStepCandidate.getInput();
                        final ProbabilisticWord nextProbabilisticWord = currentStepCandidate.getOutput();
                        final Word nextWord = nextProbabilisticWord.getWord();
                        final AffixType affixType = currentStepCandidate.getProbabilisticAffixType().getAffixType();
                        final double affixTypeProbability = currentStepCandidate.getProbability();
                        final double outputWordProbability = nextProbabilisticWord.getProbability();
                        final double aggregatedProbability = affixTypeProbability * outputWordProbability;
                        final ProbabilisticStep probabilisticStep = new ProbabilisticStep(
                                previousWord,
                                nextWord,
                                affixType,
                                affixTypeProbability,
                                outputWordProbability,
                                aggregatedProbability
                        );
                        steps.add(0, probabilisticStep);
                        currentStepCandidate = currentStepCandidate.getParent();
                    }
                    final double routeProbability = steps
                            .stream()
                            .mapToDouble(ProbabilisticStep::getAggregatedProbability)
                            .reduce(1.0, (x, y) -> x * y);
                    return MorpherEngineResponse.inflectionResponse(
                            input,
                            output,
                            pos,
                            pos.getProbability() * routeProbability,
                            steps
                    );
                })
                .collect(toList());

        final double maximumAffixTypeChainProbability = morpherEngineResponses
                .stream()
                .mapToDouble(MorpherEngineResponse::getAffixTypeChainProbability)
                .max()
                .orElse(0.0);

        morpherEngineResponses.forEach(morpherEngineResponse -> {
            final double originalAffixTypeChainProbability = morpherEngineResponse.getAffixTypeChainProbability();
            final double normalizedAffixTypeChainProbability =
                    originalAffixTypeChainProbability / maximumAffixTypeChainProbability;
            morpherEngineResponse.setNormalizedAffixTypeChainProbability(normalizedAffixTypeChainProbability);
            this.probabilityCalculator.setProbability(morpherEngineResponse);
        });

        return morpherEngineResponses;
    }

    private static List<AffixType> generateAffixTypeCandidates(final StepCandidate stepCandidate) {
        final List<AffixType> affixTypes = new ArrayList<>();
        StepCandidate currentCandidate = stepCandidate;

        do {
            final AffixType affixType = currentCandidate.getAffixType();
            affixTypes.add(affixType);
            currentCandidate = currentCandidate.getParent();
        }
        while (currentCandidate != null);

        return affixTypes;
    }

    private static boolean endsWith(final List<AffixType> longer, final List<AffixType> shorter) {
        if (longer.size() < shorter.size()) {
            return false;
        }

        final String longerString = longer
                .stream()
                .map(AffixType::toString)
                .collect(joining());
        final String shorterString = shorter
                .stream()
                .map(AffixType::toString)
                .collect(joining());

        return longerString.endsWith(shorterString);
    }

}
